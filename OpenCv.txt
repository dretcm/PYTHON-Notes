----------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------- GUIDE OpenCv -------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

1 -------------->>> Images (display, resize, rotate, save, flip, shape):

# read images:

import cv2
path = 'c:/users/usuario/pictures/dog_aux.jpg'

# -1 : cv2.IMREAD_COLOR : loads a color image(its by default).
# 0 : cv2.IMREAD_GRAYSCALE : loads a image in grayscale mode.
# 1 : cv2.IMREAD_UNCHANGED : loads image as such including alpha channel.

img = cv2.imread(path, -1)

cv2.imshow('Image', img) # (title, tensor)
cv2.waitKey(0)   # 0 : infinity time, until to press whatever key; 1000 : is equivalent to 10 seconds; 5000 : to 5 seconds, etc. # and returns key's number in ascii.
cv2.destroyAllWindows()

# resize images:

import cv2
path = 'c:/users/usuario/pictures/dog_aux.jpg'

img = cv2.imread(path, 1)
img = cv2.resize(img, (500, 400))  # (tensor, (width, height))

cv2.imshow('Image', img)
cv2.waitKey(0)
cv2.destroyAllWindows()

# resize according the porcentage:

import cv2
path = 'c:/users/usuario/pictures/dog_aux.jpg'

img = cv2.imread(path, 1)
img = cv2.resize(img, (0,0), fx=0.5, fy =0.4)  # (tensor, (width, height), porcentage of width according the original cap, porcentage of height according the original cap)

cv2.imshow('Image', img)
cv2.waitKey(0)
cv2.destroyAllWindows()

# rotate images and save images:

import cv2
path = 'c:/users/usuario/pictures/dog_aux.jpg'

img = cv2.imread(path, 1)
img = cv2.resize(img, (400, 400))

# cv2.ROTATE_90_CLOCKWISE
# cv2.ROTATE_90_COUNTERCLOCKWISE
# cv2.ROTATE_180

img = cv2.rotate(img, cv2.cv2.ROTATE_90_CLOCKWISE)   # clockwise(en sentido horario)

cv2.imwrite('new_img.jpg', img)   # save image (filename, tensor)

cv2.waitKey(0)
cv2.destroyAllWindows()

# flip:

## flipcode = 0: flip vertically
## flipcode = 1: flip horizontally
## flipcode = -1 : flip vertically and horizontally

import cv2
path = 'c:/users/usuario/pictures/dog_aux.jpg'

img = cv2.imread(path)
img = cv2.flip(img, -1)

cv2.imshow('Image', img)

cv2.waitKey(0)
cv2.destroyAllWindows()

# shape:

import cv2
path = 'c:/users/usuario/pictures/dog_aux.jpg'
img = cv2.imread(path)

print(img.shape) # output: (1200, 900, 3) # (height, width, channels(RGB)) # (tensors, rows, columns)

2 --------------->>> Image Fundamentals and Manipulation :

# array:

import cv2
img = cv2.imread('dog.png')
print(img) # array numpy
print(type(img)) # <class 'numpy.ndarray'>


# 3 channels(standar RGB, open-cv use BGR) to 1 (GrayScale):

img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)


# changue to random color in a part of image:

import cv2
import numpy as np

img = cv2.imread('dog.png')
img = cv2.resize(img, (400,400))

for i in range(100): # vectical shift
        for j in range(200): # horizontal shift
                img[i][j] = [np.random.randint(0,256), np.random.randint(0,256), np.random.randint(0,256)] # 3 channels [blue, green, red]

cv2.imshow('Image', img)
cv2.waitKey(0)
cv2.destroyAllWindows()


# BGR colors imshow of image:

import cv2
img = cv2.imread('dog.png')
img = cv2.resize(img, (400,500))

for i in range(3):
        aux = img.copy()
        for j in range(3):
                if i != j:
                        aux[:,:,j] = 0    # only one channel will have colors, the others will be matched to '0'.
        cv2.imshow('Image', aux)
        cv2.waitKey(0)
        
cv2.destroyAllWindows()


# coping and passing parts of image:

import cv2
img = cv2.imread('dog.png')
img = cv2.resize(img, (400,500))

aux = img[100:250,100:200]  # select part.
img[:150,:100] = aux   # replace part by 'aux'.

cv2.imshow('Image', img)
cv2.waitKey(0)  
cv2.destroyAllWindows()

3 --------------->>> cameras and video captures:

# display video and capture in device:

import cv2
capture = cv2.VideoCapture('BEASTARS.mp4')   # cv2.VideoCapture(0) for camera.

if not cap.isOpened(): # (True/False) if open return True.
    	print("Cannot open camera")
    	exit()

cv2.namedWindow("frame", cv2.WINDOW_NORMAL)  # define the name of display.
cv2.resizeWindow("frame", 480, 270)          # (display name to configurate, width, height).

while (True):
        ret, frame = capture.read()   # returns (bool (True/False) If the frame is read correctly, and the frame).

        if not ret:
                break

        cv2.imshow('frame',frame)
        
        if cv2.waitKey(1) == ord('q'):
                break
        
capture.release()  # close the capture or finish it.
cv2.destroyAllWindows()


# other form of resize frame:

import cv2
capture = cv2.VideoCapture('BEASTARS.mp4')

while (True):
        ret, frame = capture.read()

        if not ret:
                break

        frame = cv2.resize(frame, (480, 270)) # other form of resize frame (width, height)
        cv2.imshow('frame',frame)
        
        if cv2.waitKey(1) == ord('q'):
                break

capture.release()
cv2.destroyAllWindows()


# Properties camera, only with camera! :

0. CV_CAP_PROP_POS_MSEC Current position of the video file in milliseconds.
1. CV_CAP_PROP_POS_FRAMES 0-based index of the frame to be decoded/captured next.
2. CV_CAP_PROP_POS_AVI_RATIO Relative position of the video file
3. CV_CAP_PROP_FRAME_WIDTH Width of the frames in the video stream.
4. CV_CAP_PROP_FRAME_HEIGHT Height of the frames in the video stream.
5. CV_CAP_PROP_FPS Frame rate.
6. CV_CAP_PROP_FOURCC 4-character code of codec.
7. CV_CAP_PROP_FRAME_COUNT Number of frames in the video file.
8. CV_CAP_PROP_FORMAT Format of the Mat objects returned by retrieve() .
9. CV_CAP_PROP_MODE Backend-specific value indicating the current capture mode.
10. CV_CAP_PROP_BRIGHTNESS Brightness of the image (only for cameras).
11. CV_CAP_PROP_CONTRAST Contrast of the image (only for cameras).
12. CV_CAP_PROP_SATURATION Saturation of the image (only for cameras).
13. CV_CAP_PROP_HUE Hue of the image (only for cameras).
14. CV_CAP_PROP_GAIN Gain of the image (only for cameras).
15. CV_CAP_PROP_EXPOSURE Exposure (only for cameras).
16. CV_CAP_PROP_CONVERT_RGB Boolean flags indicating whether images should be converted to RGB.
17. CV_CAP_PROP_WHITE_BALANCE Currently unsupported
18. CV_CAP_PROP_RECTIFICATION Rectification flag for stereo cameras (note: only supported by DC1394 v 2.x backend currently)

example:

import cv2

cap = cv2.VideoCapture(0)
cap.set(3,600) # 3 for width, 4 for height
cap.set(4,500)

while True:
    ret, frame = cap.read()

    cv2.imshow('frame', frame)

    if cv2.waitKey(20) & 0xFF == ord('q'): # if press the key 'q' finish capture.
        break

cap.release()
cv2.destroyAllWindows()


# video multiple times with a camera:

import cv2
import numpy as np

cap = cv2.VideoCapture('BEASTARS.mp4')

width = int(cap.get(3))
height = int(cap.get(4))

image = np.zeros((height, width, 3), np.uint8)

width //=2  # divide the image in 4 parts.
height //=2
        
while (cap.isOpened()):
        ret, frame = cap.read()

        
        frame = cv2.resize(frame, (0,0), fx=0.5, fy=0.5)

        image[:height,:width] = frame
        image[:height, width:] = frame
        image[height:,:width] = frame
        image[height:, width:] = frame
        
        
        cv2.imshow('frame',image)
        
        if cv2.waitKey(1) == ord('q'):
                break

cap.release()
cv2.destroyAllWindows()

# video multiple times with a video, rotate and flip:

import cv2
import numpy as np

cap = cv2.VideoCapture('BEASTARS.mp4')
cv2.namedWindow("frame", cv2.WINDOW_NORMAL)
cv2.resizeWindow("frame", 880, 570)

width = int(cap.get(3))
height = int(cap.get(4))

image = np.zeros((height, width, 3), np.uint8)

width //=2
height //=2
        
while (cap.isOpened()):
        ret, frame = cap.read()

        if not ret:
                break
        
        frame = cv2.resize(frame, (0,0), fx=0.5, fy=0.5)
        
        image[:height,:width] = cv2.rotate(frame, cv2.cv2.ROTATE_180)
        image[:height, width:] = cv2.flip(frame, 0)
        image[height:,:width] = cv2.flip(frame,1)
        image[height:, width:] = frame
        
        
        cv2.imshow('frame',image)
        
        if cv2.waitKey(1) == ord('q'):
                break

cap.release()
cv2.destroyAllWindows()

4 --------------->>>

20 -------------->>> save or recording videos :

import cv2 
import pyautogui
import numpy as np
from skvideo import io

if __name__ == '__main__':
    codec = cv2.VideoWriter_fourcc(*"XVID")
    out = cv2.VideoWriter("D:\Grabacion.avi", codec , 20.0, (640, 440))

    cv2.namedWindow("Grabando", cv2.WINDOW_NORMAL)
    cv2.resizeWindow("Grabando", 480, 270) #Los ultimos dos argunmentos son las dimensiones de la ventana de grabación

    while True:
        img = pyautogui.screenshot() # tomamos un pantallazo
        frame = np.asarray(img) # convertimos la imagen a un arreglo de numeros
        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB) # Convertimos la imagen BGR a RGB
        cv2.imshow('Grabando', frame) # mostramos el cuadro que acabamos de grabar
        out.write(frame)
        if cv2.waitKey(1) == ord('q'): # si el usuario presiona 'q' paramos de grabar.
            break

    out.release() # cerrar el archivo de video
    cv2.destroyAllWindows() # cerrar la ventana


# option 2(with skvideo - pip install scikit-video):

import cv2 # OpenCV
import pyautogui
import numpy as np
from skvideo import io

if __name__ == '__main__':

    writer = io.FFmpegWriter("D:\Grabacion.avi", outputdict={
      '-vcodec': 'libx264',  #use the h.264 codec
      '-crf': '0',           #set the constant rate factor to 0, which is lossless
      '-preset':'veryslow'   #the slower the better compression, in princple, try 
                         #other options see https://trac.ffmpeg.org/wiki/Encode/H.264
    }) 

    cv2.namedWindow("Grabando", cv2.WINDOW_NORMAL)
    cv2.resizeWindow("Grabando", 480, 270) #Los ultimos dos argunmentos son las dimensiones de la ventana de grabación

    while True:
        img = pyautogui.screenshot() # tomamos un pantallazo
        frame = np.asarray(img) # convertimos la imagen a un arreglo de numeros
        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB) # Convertimos la imagen BGR a RGB
        cv2.imshow('Grabando', frame) # mostramos el cuadro que acabamos de grabar
        writer.writeFrame(frame[:,:,::-1])   # channels in reverse because in open-cv handles in BGR, but we want RGB.
        if cv2.waitKey(1) == ord('q'): # si el usuario presiona 'q' paramos de grabar.
            break

    writer.close()
    cv2.destroyAllWindows() # cerrar la ventana


# create a video with images in your disk:

path = r"D:\images"

def generate_video(path, lenght):

        writer = io.FFmpegWriter("D:\Grabacion.avi", outputdict={
              '-vcodec': 'libx264',  #use the h.264 codec
              '-crf': '0',           #set the constant rate factor to 0, which is lossless
              '-preset':'veryslow'   #the slower the better compression, in princple, try 
                                 #other options see https://trac.ffmpeg.org/wiki/Encode/H.264
        })
        
        cv2.namedWindow("Grabando", cv2.WINDOW_NORMAL)
        cv2.resizeWindow("Grabando", 480, 270)
        
        for i in range(lenght):
            img = cv2.imread(path+'\\'+f'img{i}.jpg')
            frame = np.asarray(img)
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            writer.writeFrame(frame[:,:,::-1])
            cv2.imshow('Grabando', frame)
            
        write.close()
        cv2.destroyAllWindows()

generate_video(path,361)

21 ---------------->>> Screen Recorder :
import cv2 
import pyautogui
import numpy as np
import time

if __name__ == '__main__':
    codec = cv2.VideoWriter_fourcc(*"XVID")
    out = cv2.VideoWriter("ScreenRecorder.avi", codec , 20.0, (640, 440))

    prev = 0
    fps = 120
    while True:
	time_elapsed = time.time() - prev

        img = pyautogui.screenshot()
	
	if time_elapsed > 1.0/fps:
		prev = time.time()
        	frame = np.asarray(img)
        	frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        	out.write(frame)
	cv2.waitKey(100)

    out.release()
    cv2.destroyAllWindows()

22 ---------------->>>